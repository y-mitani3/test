# test

それぞれの問ごとにプログラムを作成した。

<h2>question1.py</h2>
ログを一行ずつ読み込む。そのログの行のipアドレスで初めてタイムアウトした場合、その時のipアドレスとそれに対応する時間を辞書1に保存する。応答があった場合は辞書1にそのipアドレスがあった場合は現在のログの時間と初めてタイムアウトした時間の差を記録する。その後辞書1からそのipアドレスを削除する。
これを最後まで繰り返す。<bd>
結果はresult/result1.txtに保存される。<bd>
  
## Usage
```
$ python3 question1.py
```
<h2>question2.py</h2>
ログを1行ずつを読み込むのは同じ。そのログの行がタイムアウトした場合はそのipアドレスとそのipアドレスで始めてタイムアウトした時間を辞書1に保存しておく。またipアドレス毎に連続タイムアウト回数をカウントし1増やす。その回数がn回以上だった場合はそのipアドレスと初めてタイムアウトした時間を辞書2に保存する。<bd>そのログの行で応答があった場合は、そのipアドレスを辞書1から削除する。また連続タイムアウト回数を0にリセットする。辞書2でn回以上タイムアウトした記録が現在のログの時間と初めてタイムアウトした時間の差を記録する。その後そのipアドレスを辞書2から削除する。これを最後まで繰り返す。<bd>
引数nはn回以上連続してタイムアウトするかを表す整数とする。<bd>
結果はresult/result2.txtに保存される。<bd>
n=2の場合を実行した。<bd>
  
## Usage
```
$ python3 question2.py n
```
  
<h2>question3.py</h2>
ログを1行ずつを読み込むのは同じ。各ipアドレスに対応する過去m回の応答時間を保持しておく。過去の応答回数がm回未満の場合は過去の全ての平均時間,m回以上の場合はm回の平均時間を計算する。平均時間がt秒を越えた場合は過負荷状態であると判定する。過負荷だった場合は、そのipアドレスとそのipアドレスで初めて過負荷状態になった時間を辞書1に保存する。過負荷ではない場合は、辞書1にそのipアドレスがあった場合は現在のログの時間と初めてタイムアウトした時間の差を記録する。その後辞書1からそのipアドレスを削除する。これを最後まで繰り返す。<bd>
引数mはm回の平均を取る数。引数tは過負荷状態と判定する時間とする。<bd>
結果はresult/result3.txtに保存される。<bd>
m=3,t=10の場合を実行した。<bd>
  
## Usage
```
$ python3 question3.py m t
```
  
<h2>question4.py</h2>
ログを1行ずつを読み込むのは同じ。毎回各ipアドレスのネットワークアドレスを計算する。故障期間なので問2を拡張する。サブネットの中にある各ホストの連続タイムアウト回数をカウントする。そのログの行がタイムアウトした場合はそのipアドレスとそのipアドレスで始めてタイムアウトした時間を辞書1に保存しておく。またipアドレス毎に連続タイムアウト回数をカウントし1増やす。その回数がn回以上だった場合はそのipアドレスと初めてタイムアウトした時間を辞書2に保存する。サブネット内の全てのホストの連続タイムアウト回数がn回を越えた場合はサブネットの故障と判定する。<bd>
そのログの行で応答があった場合はそのipアドレスを辞書1から削除する。また連続タイムアウト回数を0にリセットする。辞書2でn回以上タイムアウトした記録が現在のログの時間と初めてタイムアウトした時間の差を記録する。その後そのipアドレスを辞書2から削除する。これを最後まで繰り返してネットワークアドレス毎にまとめて故障期間を出力する。<bd>
引数nはn回以上連続してタイムアウトするかを表す整数とする。<bd>
結果はresult/result4.txtに保存される。<bd>
n=2の場合を実行した。<bd>
  
## Usage
```
$ python3 question4.py n
```
  
