# test

それぞれの問ごとにプログラムを作成した。

<h2>question1.py</h2>
ログを一行ずつ読み込む。そのipアドレスで初めてタイムアウトした場合、その時のipアドレスとそれに対応する時間を保存する。普通の場合は直前にタイムアウトしていた場合は現在のログの時間と初めてタイムアウトした時間の差を記録する。これを最後まで繰り返す。<bd>
  
<h2>question2.py</h2>
監視ログファイルを読み込むのは同じ。タイムアウトした場合はそのipアドレスと対応する時間を辞書1に記録しておく。それがn回以上だった場合はそのipアドレスと初めてタイムアウトした時間を辞書2に保存する。<bd>タイムアウトではない場合は、そのipアドレスと対応する時間の記録を辞書1から削除する。辞書2でn回以上タイムアウトした記録があればそれを削除して、現在のログの時間と初めてタイムアウトした時間の差を記録する。これを最後まで繰り返す。<bd>

<h2>question3.py</h2>
監視ログファイルを読み込むのは同じ。各ipアドレスに対応する過去m回の応答時間を保持しておく。m回前の記録を破棄し現在の応答時間を最後尾に加える。m回の平均時間を計算する。t秒を越えた場合は過負荷状態であると判定する。過負荷だった場合は、そのipアドレスとそこで初めて過負荷状態になった時間を保存する。過負荷ではない場合は、直前が過負荷である場合は現在時間とそのipアドレスと初めて過負荷状態になった時間の差を保存する。これを最後まで繰り返す。<bd>

<h2>question4.py</h2>
監視ログファイルを読み込むのは同じ。毎回各ipアドレスのネットワークアドレスを計算する。故障期間なので問2を拡張する。サブネットの中にある各ホストの連続タイムアウト回数を記録する。サブネット内の全てのホストの連続タイムアウト回数がn回を越えた場合はサブネットの故障と判定する。タイムアウトしていないは問2と同様に現在のログの時間と初めてタイムアウトした時間の差を記録する。これを最後まで繰り返す。<bd>

## Usage
```
$ python3 question1.py
$ python3 question2.py
$ python3 question3.py
$ python3 question4.py  
```
